#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Wed Apr  4 15:00:54 2018

This file runs Generative Neural Networks for Differentiable Evolutionary Search (GENNES) as described in
https://arxiv.org/abs/1805.08594.
@author: l.faury
"""

import os

import argparse
import matplotlib
matplotlib.use('Agg')  # enables matplotlib to be used in virtualenv
import matplotlib.pyplot as plt
import numpy as np
import pprint as pp
import tensorflow as tf

import generator as gen
import objective as obj
import utils as ut


def main(args):

    # Hyperparameters
    bb_dim = args['bbdim']
    fevals = args['fevals']
    glr = args['glr']
    nannealing = args['nannealing']
    nmag = args['nmag']
    noise_dim = args['ndim']
    pop_size = args['popsize']
    seed = args['seed']
    stop_criter = args['stopcriter']

    # Reproducibility
    tf.reset_default_graph()
    tf.set_random_seed(seed)
    np.random.seed(seed)

    # RUNNING OPTIMIZATION
    with tf.Session() as session:

        # Objective definition
        bbo = obj.Rastrigin(bb_dim)

        # Generator instance
        opt = gen.Generator(bb_dim=bb_dim,
                            noise_dim=noise_dim,
                            step_size=glr,
                            pop_size=pop_size)

        # Initialization
        session.run(tf.global_variables_initializer())
        popv = []  # population values array
        popi = []  # population individuals array

        # Optimization
        i = 0
        cur_min = np.inf
        max_iter = int(fevals * bb_dim / pop_size)
        stop = False
        while (i < max_iter and not(stop)):

            # Generate the input samples for the generator
            samples = np.random.uniform(-nmag, nmag, size=(pop_size, noise_dim))
            nmag *= nannealing

            # Generates the outputs
            queries = session.run(opt.y, feed_dict={opt.x: samples})

            # Generates the gradients outputs
            (fvals, dfvals) = bbo.bbox_oracle1(session, queries)

            # Train the generator
            session.run(opt.update, feed_dict={opt.x: samples, opt.fgrad: dfvals})

            # Fill in arrays for post-processing
            popv.append(fvals)
            popi.append(queries)
            popmin = np.min(fvals)

            # Stopping criterion
            if popmin <= cur_min:
                cur_min = popmin
            stop = popmin <= stop_criter
            i += 1

        # Prints performances
        mins = np.min(popv, axis=1)
        print('End at iteration ', i, '/', max_iter)
        print('Minimum value found is %s at iteration %s' %
              (np.min(mins), np.argmin(mins)))

        # PLOTS
        img_dir = './img'
        if not os.path.exists(img_dir):
            os.makedirs(img_dir)
        # Simple regret plot
        ut.plot_perf(mins, pop_size)

        # Plot populations if dimension=2
        if args['bbdim'] == 2:
            ut.plot_contours(session, bbo, popi)


if __name__ == '__main__':

    parser = argparse.ArgumentParser(description='Deep Black-Box Optimization Parameters',
                                     formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument('--bbdim', help='Dimension of the black-box optimization problem', default=2,type=int)
    parser.add_argument('--ndim', help='Dimension of the input noise for the generator', default=2,type=int)
    parser.add_argument('--fevals', help='Function evaluations budget', default=1e3,type=int)
    parser.add_argument('--glr', help='Generative network learning rate', default=1e-4)
    parser.add_argument('--popsize', help='Population size generated by the generative network', default=20,type=int)
    parser.add_argument('--nmag', help='Magnitude (support) of the generators input noise', default=2)
    parser.add_argument('--nannealing', help='Annealing factor for the input noise', default=0.99)
    parser.add_argument('--seed', help='Random seed for reproducibiltiy', default=1, type=int)
    parser.add_argument('--stopcriter', help='Stop criterion for the search', default=1e-8)

    args = vars(parser.parse_args())
    pp.pprint(args)
    main(args)
